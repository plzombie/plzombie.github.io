<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Рисования линий, заполнения областей на растре, аффинные преобразования и другая магия</title>
<script type="text/javascript">
	var cavnas1, context1, canvas2, context2, canvas3, context3;
	var width, height;
	var points = { isDotGrabbed: 0, data: [] }; // Точки полигона
	var path = { isDotGrabbed: 0, data: [] }; // Путь, по которому проходит фигура
	var rotangle = 0; // Угол поворота
	var pathpos = 0; // Позиция в пути
	var polygon_bordercolor = "rgba(0, 0, 0, 255)";
	var polygon_fillcolor = "rgba(64, 255, 128, 255)";
	// Очищает данные и перерисовывает изображения
	function RedrawMyImages() {
		points = { isDotGrabbed: 0, data: [] };
		path = { isDotGrabbed: 0, data: [] };
		
		context1.fillStyle = "rgb(255, 255, 255)";
		context1.fillRect(0, 0, width, height);
		DrawDots(context1, points, "rgb(0, 0, 0)");
		
		DrawScene();
		
		context3.fillStyle = "rgb(255, 255, 255)";
		context3.fillRect(0, 0, width, height);
		DrawDots(context3, path, "rgb(0, 0, 0)");
	}
	function DrawLine(context, x1, y1, x2, y2, color) {
		context.strokeStyle = color;
		context.beginPath();
		context.moveTo(x1, y1);
		context.lineTo(x2, y2);
		context.stroke();
	}
	function SetRotMatrix(angle) {
		return new Array(
			Math.cos(angle), Math.sin(angle), 0, 
			-Math.sin(angle), Math.cos(angle), 0,
			0, 0, 1);
	}
	function MultVec3Mat3x3(vec, mat) {
		newvec = [0, 0, 0];
		
		for(var i = 0; i < 3; i++) {
			for(var j = 0; j < 3; j++) {
				newvec[i] += vec[j]*mat[j*3+i];
			}
		}
		
		return newvec;
	}
	function AddVec3Vec3(vec1, vec2) {
		return new Array(vec1[0]+vec2[0], vec1[1]+vec2[1], vec1[2]+vec2[2]);
	}
	function SubVec3Vec3(vec1, vec2) {
		return new Array(vec1[0]-vec2[0], vec1[1]-vec2[1], vec1[2]-vec2[2]);
	}
	// Возвращает вектор - центр полигона poly
	function CalculatePolygonCentre(poly) {
		p = [0, 0, 0]
		if(poly.data.length > 0) {
			for(var i = 0; i < poly.data.length; i++) {
				p[0] += poly.data[i][0];
				p[1] += poly.data[i][1];
			}
			p[0] /= poly.data.length;
			p[1] /= poly.data.length;
		}
		
		return p;
	}
	// Возвращает вектор - позицию полигона на пути path с учётом пройденного пути pathpos
	function CalculatePolygonPosition() {
		if(path.data.length > 0) {
			var p = [0, 0, 0];
			var firstpos = Math.floor(pathpos)%path.data.length;
			var secondpos = (firstpos+1)%path.data.length;
			var delta = pathpos-Math.floor(pathpos);
			
			p[0] = path.data[firstpos][0]*(1-delta)+path.data[secondpos][0]*delta;
			p[1] = path.data[firstpos][1]*(1-delta)+path.data[secondpos][1]*delta;
			
			return p;
		} else {
			return CalculatePolygonCentre(points);
		}
	}
	// Рисует полигон poly
	function DrawPolygon(context, poly, ppos, angle, bordercolor, fillcolor) {
		var ppc = CalculatePolygonCentre(poly);
		
		if(poly.data.length > 0) {
			var mat = SetRotMatrix(angle);
			var p0 = AddVec3Vec3(MultVec3Mat3x3(SubVec3Vec3(poly.data[0], ppc), mat), ppos);
			var p;
			
			context.strokeStyle = bordercolor;
			context.fillStyle = fillcolor;
			context.beginPath();
			
			context.moveTo(p0[0], p0[1]);
			
			for(var i = 1; i < poly.data.length; i++) {
				p = AddVec3Vec3(MultVec3Mat3x3(SubVec3Vec3(poly.data[i], ppc), mat), ppos);
				context.lineTo(p[0], p[1]);
			}
			context.lineTo(p0[0], p0[1]);
			context.stroke();
			context.fill();
		}
	}
	// Рисует линии по контуру полигона poly
	function DrawLines(context, poly, color) {
		if(poly.data.length > 0) {
			var p0 = poly.data[0];
			var p1, p2 = p0;
			
			for(var i = 1; i < poly.data.length; i++) {
				//alert("i "+i+" pl "+poly.data.length);
				p1 = p2;
				p2 = poly.data[i];
				DrawLine(context, p1[0], p1[1], p2[0], p2[1], color);
				//alert("i "+i+" pl "+poly.data.length);
			}
			DrawLine(context, p2[0], p2[1], p0[0], p0[1], color);
		}
	}
	// Рисует точки из dots
	function DrawDots(context, dots, color) {
		for(var i = 0; i < dots.data.length; i++) {
			context.fillStyle = color;
			context.fillRect(dots.data[i][0], dots.data[i][1], 1, 1);
		}
	}
	// Рисует анимированную сцену
	function DrawScene() {
		context2.fillStyle = "rgb(255, 255, 255)";
		context2.fillRect(0, 0, width, height);
		DrawLines(context2, path, "rgb(255, 128, 255)");
		DrawPolygon(context2, points, CalculatePolygonPosition(), rotangle, polygon_bordercolor, polygon_fillcolor);
		rotangle += 0.157;
		pathpos += 0.05;
	}
	// Добавляет в dots точку, на которую вы указали. Здесь event - событие, canvas - холст, на который вы кликнули
	function AddClickedDots(event, canvas, context, dots) {
		var p = canvas;
		var x = event.clientX+document.body.scrollLeft+document.documentElement.scrollLeft;
		var y = event.clientY+document.body.scrollTop+document.documentElement.scrollTop;
		while(p) {
			x -= p.offsetLeft;
			y -= p.offsetTop;
			p = p.offsetParent;
		}
		var dot = [x, y, 1];
		if(dots.isDotGrabbed > 0) {
			dots.data[dots.isDotGrabbed-1] = dot;
			dots.isDotGrabbed = 0;
			
			context.fillStyle = "rgb(255, 255, 255)";
			context.fillRect(0, 0, width, height);
			DrawDots(context, dots, "rgb(0, 0, 0)");
		} else {
			for(var i = 0; i < dots.data.length; i++) {
				if((Math.abs(x-dots.data[i][0]) <= 3) &&
					(Math.abs(y-dots.data[i][1]) <= 3)) {
					dots.isDotGrabbed = i+1;
					context.fillStyle = "rgb(0, 255, 0)";
					context.fillRect(dots.data[i][0]-1, dots.data[i][1]-1, 3, 3);
					context.fillStyle = "rgb(0, 0, 0)";
					context.fillRect(dots.data[i][0], dots.data[i][1], 1, 1);
					return;
				}
			}
			context.fillStyle = "rgb(0, 0, 0)";
			context.fillRect(x, y, 1, 1);
			dots.data[dots.data.length] = dot;
		}
	}
	function AddDot(event) {
		AddClickedDots(event, canvas1, context1, points);
	}
	function AddPath(event) {
		AddClickedDots(event, canvas3, context3, path);
	}
	function ChangeBorderColor() {
		polygon_bordercolor = document.getElementById('bordercolor').value;
	}
	function ChangeFillColor() {
		polygon_fillcolor = document.getElementById('fillcolor').value;
	}
	window.onload = function () {
		canvas1 = document.getElementById('canvas1');
		context1 = canvas1.getContext('2d');
		width = canvas1.width;
		height = canvas1.height;
		
		canvas2 = document.getElementById('canvas2');
		context2 = canvas2.getContext('2d');
		canvas2.width = width;
		canvas2.height= height;
		
		canvas3 = document.getElementById('canvas3');
		context3 = canvas3.getContext('2d');
		canvas3.width = width;
		canvas3.height= height;
		
		RedrawMyImages();
		
		canvas1.addEventListener('click', AddDot);
		canvas3.addEventListener('click', AddPath);
		
		document.getElementById('bordercolor').value = polygon_bordercolor;
		document.getElementById('fillcolor').value = polygon_fillcolor;
		
		setInterval("DrawScene();", 50);
	}
</script>
</head>
<body style="background: gray;">
<table>
<tr>
	<td>Polygon<br/><canvas id="canvas1" width="200" height="200"></canvas></td>
	<td>Result<br/><canvas id="canvas2" width="200" height="200"></canvas></td>
	<td>Path<br/><canvas id="canvas3" width="200" height="200"></canvas></td>
</tr>
<tr>
	<td><button onclick="RedrawMyImages();">Очистить</button></td>
	<td colspan="2">
		<p style="text-align:left">
		Граница:<input type="text" id="bordercolor" value="rgba(0, 0, 0, 255)" style="width:200px">
		<button onclick="ChangeBorderColor();">Изменить</button>
		</p>
		<p style="text-align:left">
		Заливка:<input type="text" id="fillcolor" value="rgba(0, 0, 0, 255)" style="width:200px">
		<button onclick="ChangeFillColor();">Изменить</button>
		</p>
	</td>
</tr>
</table>
<p>На холсте Polygon отмечаются точки фигуры</p>
<p>На Path - точки пути, по которому движется фигура</p>
<p>На Result рисуется итоговое изображение</p>
<p>Чтобы переместить точку, нужно кликнуть на неё, затем кликнуть на новую позицию</p>
</body>
</html>